> 2020-06-18-점심시간

# Node.js 교과서

## 1 노드 시작하기

### 1.1 핵심 개념 이해하기

Node.js 는 자바스크립트 런타임이다.

- 크롬 V8 자바스크립트 엔진으로 빌드됐다.
- 이벤트 기반, 논블로킹 I/O 모델을 사용한다.
- npm 패키지 생태계

네트워크를 통해 정보나 서비스를 제공하면 서버라고 할 수 있다.

자바스크립트 실행 속도가 너무 느렸다. 2008년 구글이 V8 엔진을 사용한 크롬이 출시됐는데 자바스크립트 실행 속도가 매우 빨랐고, 같은 V8 엔진을 사용해 만든 런타임이 노드다.

노드는 libuv 라이브러리를 사용하며, 이 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현하고 있다.

이벤트 기반(event-driven)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 말한다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 실행할 지는 이벤트 루프가 결정한다. (이벤트 루프, 호출 스택, 백그라운드, 태스크 큐)

> 참고: [Concurrency model and the event loop - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)

논블로킹이란 현재 작업이 완료될 때까지 기다리지 않고 다음 작업을 수행하는 걸 말한다. 노드는 싱글 스레드를 사용하기 때문에 노드 프로세스 외의 I/O 작업을 할 때 논블로킹 방식으로 동작한다. (동기/비동기, 블로킹/논블로킹)

멀티 스레드가 항상 싱글 스레드보다 좋은 건 아니다. (싱글/멀티 스레드, 블로킹/논블로킹, 주방, 점원, 고객)

프로세스는 운영체제에서 할당하는 작업의 단위이다. 프로세스 간 메모리 등의 자원을 공유하지 않는다. 스레드는 프로세스 내에서 실행되는 흐름의 단위다. 부모 프로세스의 자원을 공유한다.

사실 노드 프로세스도 내부적으로는 스레드를 여러 개 가지고 있지만, 우리가 직접 제어할 수 있는 스레드가 하나뿐인 것이다.

노드는 멀티 프로세싱 방식을 택한 이유는 자바스크립트 언어가 싱글 스레드 특성을 띠고 있기 때문이다.

### 1.2 서버로서의 노드

I/O가 많은 작업에 적합하다. 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 작업. 실시간 채팅 앱, 주식 차트, JSON 데이터를 제공하는 API 서버.

CPU 부하가 큰 작업에는 적합하지 않다.

자바스크립트를 사용하므로 웹 사이트를 하나의 언어로 개발할 수 있어서 개발 생산성을 높여준다.

비동기는 Go가 낫다. 정적 파일 제공, 로드 밸런싱은 nginx가 낫다.

안정성, 보안성은 충분히 검증됐다.

> 2020-07-03-점심시간

## 3 노드 기능 알아보기

### 3.7 이벤트 이해하기

어떤 이름의 이벤트가 발생할 때 콜백 함수를 호출하도록 이벤트를 등록할 수 있다.

- `on`, `addListener` : 이벤트 이름, 콜백 함수를 연결해서 이벤트를 만든다
- `emit` : 이벤트를 호출한다
- `once` : 한 번만 실행되는 이벤트를 만든다
- `off`, `removeListener` : 이벤트에 연결된 리스너를 제거한다
- `listenerCount` : 연결된 리스너 개수를 확인한다

### 3.8 예외 처리하기

노드는 단일 스레드 방식이므로 에러가 발생하면 전체 서버가 멈춘다.

예측 가능한 에러는 `try-catch` 문으로 처리한다.

```javascript
try { ... } catch (error) { ... }
```

예측 불가능한 에러는 다음과 같이 걸러낼 수 있지만 최후의 수단이다.

```javascript
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit();	// 이 이벤트 발생 후 다음 동작이 제대로 동작하는지 보증할 수 없다
});
```

서버 운영은 에러와의 싸움이다. 미처 대비하지 못한 에러도 철저히 기록해서 보완해 나가야 한다.

## 4 http 모듈로 웹 서버 만들기

### 4.1 요청과 응답 이해하기

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
});
server.listen(8080);
server.on('listening', () => {
  console.log('Server is listening on port 8080');
});
server.on('error', (rror) => {
  console.error(error);
});

```

리눅스, macOS 에서 1024 이하의 포트에 연결하려면 관리자 권한이 필요하다.

### 4.2 쿠키와 세션 이해하기

누가 요청을 보내는지 알기 위해서 쿠키와 세션을 알아야 한다.

1. 클라이언트의 첫 번째 요청
2. 서버의 쿠키가 추가된 첫 번째 응답
   `res.writeHead(200, {'Set-Cookie': 'mycooki=test' });`
3. 이후 클라이언트는 쿠키를 포함해서 요청
4. 서버는 쿠키 추가하지 않고 그대로 응답

favicon에 대한 정보가 없으면 브라우저에서 추가로 `/favicon.ico` 를 요청한다.

### 4.3 REST API와 라우팅

REST API의 HTTP 요청 메서드: get, post, put, patch, delete

요청이 어떤 메서드를 사용했는지 `req.method` 값으로 알 수 있다.

(4.4 https와 http2 읽을 차례)

