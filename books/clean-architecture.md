클린 아키텍처: 소프트웨어 구조와 설계의 원칙, 로버트 C. 마틴 지음, 송준이 옮김

---

**3부. 설계 원칙**

9장. LSP: 리스코프 치환 원칙

- 정사각형/직사각형 문제 → 하위 타입으로 적절하지 못한 예
- 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성
- 인터페이스를 위배하면 if 문 지옥이 펼쳐진다

10장. ISP: 인터페이스 분리 원칙

- 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다
- 전혀 관계없는 기능을 수정하기 위해 재배포해야 하는 일이 생겨서는 안 된다

11장. DIP: 의존성 역전 원칙

- 의존성이 추상에만 의존하고, 구현체에는 의존하지 않는 시스템
- 현실적으로 String 과 같이 안정성이 보장된 구체에는 의존해도 괜찮다
- 안정된 소프트웨어 아키텍처란 안정된 추상 인터페이스를 선호하는 아키텍처를 말한다
- 추상 팩토리(Abstract Factory) 패턴으로 의존성을 관리할 수 있다
- 소스 코드 의존성이 제어흐름과 반대 방향으로 역전되므로 의존성 역전이라고 부른다

---

**4부. 컴포넌트 원칙**

12장. 컴포넌트

- 배포할 수 있는 가장 작은 단위가 컴포넌트다
- 잘 설계된 컴포넌트는 독립적으로 개발 가능한 능력을 갖추고 있어야 한다
- 50년이 지나고 나서야 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일을 다룰 수 있게 됐다
- 이 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다

13장. 컴포넌트 응집도

- REP: 재사용/릴리즈 등가 원칙, Reuse/Release Equivalence Principle

  - 릴리즈 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다
  - 하나의 컴포넌트로 묶인 클래스와 모듈들은 반드시 함께 릴리즈할 수 있어야 한다
  
- CCP: 공통 폐쇄 원칙, Common Closure Principle

  - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라
  - 코드가 변경되어야 할 일이 있을 때, 최소한의 컴포넌트만 수정되어야 한다
  - 100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 한다
  - 컴포넌트 수준의 SRP다
  
- CRP: 공통 재사용 원칙, Common Reuse Principle

  - 사용하지 않는 클래스를 가진 컴포넌트에 의존해선 안 된다
  - ISP의 포괄적인 버전이다
  
- 균형 다이어그램

  - REP, CCP는 컴포넌트를 더 크게 만들고, CRP는 컴포넌트를 작게 만든다
  - 이 원칙들이 균형을 이루는 방법을 찾아야 한다
  - 개발 단계에 따라 균형도 변할 수 있음을 이해해야 한다
  - 프로젝트의 초점은 개발가능성에서 재사용성으로 바뀌어 간다

14장. 컴포넌트 결합

- ADP: 의존성 비순환 원칙

  - 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다
  - 주 단위 빌드, 의존성 비순환 원칙을 통해 이를 막을 수 있다
  - 비순환 방향 그래프, Directed Acyclic Graph, DAG
  - 의존성 순환이 생길 경우, 의존성 역전 원칙(DIP)을 적용하거나 새 컴포넌트를 만들어 해결할 수 있다
  - 컴포넌트 구조는 하향식으로 설계될 수밖에 없고, 프로젝트 초기에 설계할 수 없다.
  - 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도다
  
- SDP: 안정된 의존성 원칙

  - 안정성의 방향으로(더 안정된 쪽에) 의존하라
  - 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다
  - 의존한다/책임진다, 의존적이다/독립적이다
  - Fan-in: 안으로 들어오는 의존성
  - Fan-out: 밖으로 나가는 의존성
  - 불안정성 I = Fo / (Fi + Fo) [0, 1]
  - 의존성 방향으로 갈수록 I 지표 값이 감소해야 한다
  - 인터페이스만을 포함하는 컴포넌트는 다른 컴포넌트가 의존할 수 있는 이상적인 대상이다
  - 루비, 파이썬 같은 동적 타입 언어에서는 추상 컴포넌트가 전혀 존재하지 않는다. 의존성을 역전시킬 때 인터페이스를 선언하거나 상속받는 일이 전혀 필요하지 않기 때문이다.
  
- SAP: 안정된 추상화 원칙

  - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다
  - 안정된 컴포넌트는 추상 컴포넌트여야 하고, 불안정한 컴포넌트는 구체 컴포넌트여야 한다
  - Nc: 컴포넌트의 클래스 개수
  - Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
  - A: 추상화 정도, A = Na / Nc
  - A/I 그래프 상에서 (0, 1) ~ (1, 0)을 잇는 선분을 주계열이라고 부르며 유의미한 구역이다
  - A/I 그래프 상에서 (0, 0) 주변은 고통의 구역, (1, 1) 주변은 쓸모없는 구역이라고 부른다
  
- 좋은 의존성도 있지만 좋지 않은 의존성도 있다

---

**5부. 아키텍처**

15장. 아키텍처란?

- **소프트웨어 아키텍트**는 직접 개발하는 개발자이며, 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어준다
- **아키텍쳐**의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 것이다
- 구체적으로는 시스템의 개발, 배포, 운영, 유지보수에 영향을 준다

  - 개발과 배포가 쉽다
  - 시스템의 운영 방식을 잘 드러내서 시스템을 이해하기 쉽다
  - 유지보수할 때 기능을 추가하기 쉽고, 의도치 않은 장애가 발생할 위험이 적다
  
- 소프트웨어 시스템은 정책과 세부사항으로 분해할 수 있다

  - 정책은 업무 규칙과 절차를 구체화한 것이고,
  - 세부사항은 정책을 실제로 실행하는 것이지만 정책에는 영향을 미치지 않는다
  - 아키텍트의 목표는 시스템에서 정책을 파악하고, 세부사항을 분리하는 것이다

16장. 독립성

- 좋은 아키텍처는 시스템의 유스케이스, 운영, 개발, 배포를 지원해야 한다
- 유스케이스 관련 요소는 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라, 기능을 분명하게 설명하는 이름을 가질 것이다
- 각 컴포넌트를 적절히 분리하면 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하기 쉬울 것이다

  - 콘웨이의 법칙: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다
  - 다시 말하면, 조직의 팀별로 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할한다
  
- 환경이 급변하는 현실에서도 비용이 크지 않은 아키텍처 원칙들을 적용해서 선택사항을 열어둬야 한다
- 시스템은 서로 결합되지 않은 수평적인 계층으로 분리할 수 있다: UI, 앱에 특화된 업무 규칙, 앱과 독립적인 업무 규칙, 데이터베이스
- 동시에 수직적인 유스케이스로 시스템을 분할할 수 있다

| 유스케이스   | 주문 추가                | 주문 삭제                |
| ------------ | ------------------------ | ------------------------ |
| UI           | 주문 추가용 UI           | 주문 삭제용 UI           |
| 업무 로직    | 주문 추가용 업무 로직    | 주문 삭제용 업무 로직    |
| 데이터베이스 | 주문 추가용 데이터베이스 | 주문 삭제용 데이터베이스 |

- 하지만 유스케이스별로 다른 서버에서 실행하려면 결합을 분리할 때 적절한 모드를 선택해야 한다
- 유스케이스가 잘 분리된 시스템 아키텍처는 어떤 형태의 팀이라도 그 팀의 구조를 뒷받침해줄 것이다
- 중복에는 진짜 중복과 **우발적 중복**이 있다

  - 중복으로 보이는 두 코드 영역이 서로 다른 속도와 이유로 변경된다면 이는 우발적 중복이다
  - 따라서 반사적으로 중복을 제거하지 말고, 진짜 중복인지 확인해야 한다
  
- 계층과 유스케이스를 분리하는 방법은 다양하다:

  - 소스 코드 모듈 사이의 의존성을 제어할 수 있으며, 이를 모노리틱 구조라고 부른다
  - 배포 가능한 파일 단위 사이의 의존성을 제어할 수 있다
  - 의존 수준을 데이터 구조 단위까지 낮추고, 컴포넌트끼리 통신하도록 하면 서비스 수준으로 제어할 수 있다
  - 시스템이 한 서버에서 실행되는 경우는 소스 수준에서 분리하는 것만으로도 충분하다
  - 컴포넌트가 서비스화될 가능성이 있다면 초기에는 소스 코드 수준에서 분리하고, 서비스 수준으로 전환할 배포 단위를 선택한 후 점차적으로 변경해 나간다
  
- 시스템 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 이러한 변경을 예측해서 큰 무리 없이 반영할 수 있도록 만들어야 한다

17장. 경계: 선 긋기

- 인적 자원의 효율을 떨어뜨리는 요인은 너무 일찍 내려진 결정에 따른 결합(coupling)이다

  - 반대로 말해 좋은 시스템 아키텍처란 이러한 결정이 부수적이고, 이러한 결정을 연기할 수 있는 아키텍처다
  
- 관련이 있는 것과 없는 것 사이에 경계선을 그으면 이러한 아키텍처를 만들 수 있다
- 경계를 사이에 둔 양쪽은 서로 다른 속도로, 다른 이유로 변경된다(SRP)
- 소프트웨어 아키텍처에 경계선을 그리려면

  - 시스템을 컴포넌트 단위로 분할하고
  - 핵심 업무 규칙이 아닌 컴포넌트는 플러그인으로 구성한다

